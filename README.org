* PyNTL: Bindings for NTL

[[https://libntl.org/]]

It's used for playing around with number theory. Most of the bindings
focuses on finite fields or polynomials over these.

My own personal intended use case is for a hobby of sometimes playing
in [[https://m13h.github.io/html/notes.html][CTFs]].

* Status

- Work in progress.

- So far it's just basic wrapping and interaction of five "base
  rings," their univariate polynomials, vectors and matrices over
  them.
  
- True alpha: proof-of-concept level of code quality, API changes over night, Python will core
  dump on anything unexpected.

- =lzz_p= related types not wrapped yet. No plans to wrap any of the
  floating precision types.

- Vector and matrix functionality is minimal.

- Nearly none of the actual meaty algorithms are interfaced yet.

* Basic Usage

[TODO]

#+begin_src python
from ntl.all import ZZ

# ZZ is the ring of integers and the main convenience interface.

# You can do ZZ/n to make a ring of integers modulo n:
R = ZZ/17

# Getting elements in this ring:
a = R(5)

# Usual arithmetic should work, all being modulo 17.
print(a**4 * (a - 1))

print(1/R(2)) # Division modulo 17.

# Polynomial rings are made with `.P` (API subject to change):

Rx = R.P # Polynomials over F.

# Lists can be converted to polynomials, constant term first, lead term last.
# So [3,2,1] represents x**2 + 2*x**2 + 1

x = Rx([0, 1]) # Defining the polynomial `x`.

P = (x**2 + 2) * (x - 1)
Q = (x**7 - 1) * (x**2 - 1)

print(P.gcd(Q)) # Polynomial GCD.

# And so forth.

#+end_src

* Why Not Just Use Sage?

Actually, you're right! If you need anything in this library, you are
probably better off using Sage instead.

There's simply no comparison. Sage also embeds the FLINT library,
which I believe is somewhat leaner for smaller moduli.

Also, Sage isn't merely a [[https://doc.sagemath.org/html/en/reference/spkg/][kitchensink of libraries]], it has several
special advantages that /cannot/ be replicated in regular CPython by
adding extension types or bindings, because it builds its own version
of CPython.

For example, in Sage the default type for integer literals is a
wrapper for GMP, which can be a big deal depending on how much bigint
arithmetic you do. GMP is /a lot/ more efficient than Python's simpler
homemade implementation.

I would love to be able to do something like that in CPython, but I
know of no way to it sanely. (There are some [[https://github.com/dutc/rwatch][insane ways]].) I really
wish there was a way to hook into the tokenizer or parser in the
Python language, e.g. by way of AST or syntax-macros, but that's
something that will probably never be added to Python.

The idea for this library though, is just because I think (regular)
Python should have something like this that isn't some huge computer
algebra system that's gigabytes to install.

* API Documentation

[todo: docstrings?]

What currently works:

- additive arithmetic and multiplication for all rings (=+=, =-=, =*=).
- exponentiation for all rings except vectors. Negative exponentiation
  only for finite rings.
- finite rings have inverse (=~=) and true division (=/=). Division
  with infinite rings works as a /checked/ division, failing if the
  division is not exact.
- infinite rings have remainder (=%=) and quotient (=//=) (including
  =divrem()=).
- infinite rings also have shift operators (=<<= and =>>=).
- only the integers are ordered (=<= ~<=~ and so on). Equality and
  inequality works for all types.

Quirks and conveniences:

- =GF2X= ($\mathbb{F}_2[X]$) are made to work like integers. That is,
  combining a polynomial with an integer in some way (e.g.
  arithmetic), the integer will be interpreted as a polynomial in the
  natural way (more significant bits correspond to higher exponent
  coefficient). Usually this is what you (at least, I) want when
  working with polynomials over GF(2), e.g. CRC sums and the like.
  Merely projecting integers down to $\mathbb{F}_2$ (i.e. discaring
  all but the least bit) is not very interesting.
- Z_p lifts to ZZ, GF2E lifts to GF2X, Z_pE lifts to Z_pX.
- ZZX extended GCD is weird (look into this).

** ZZ

[todo]

** Finite scalar rings

[todo]

** Polynomials

[todo]

P, Q âˆˆ RX

- RX.monomial(deg)

  Returns the polynomial ~X**deg~ in the given ring.

- RX.random(deg, monic=False)

  Returns a random polynomial in the given ring.

  *Finite characteristic only.*
  
- RX.irreducible(deg, kind='default')

  Gives an irreducible polynomial.

  - ~kind="default"~ uses NTL's default way of building polynomials.
    ~deg~ is interpreted as the integer degree.
  - ~kind="sparse"~ is only available for GF2X and gives the first
    polynomial polynomial with fewest and lowest terms.
  - ~kind="random"~ uses a given irreducible polynomial (~deg~
    parameter) to build a another random irreducible polynomial of the
    same degree. If ~deg~ is an integer, it will use ~RX(deg,
    'default')~.

  *Finite characteristic only.* (For now.)

- P(x), len(P), ~P<<n~, ~P>>n~
- lift()
- diff(), reverse(n=0), truncate(n)
- lead_coeff(), constant()
- content(), primitive()
- P.is_monic() -> bool

  Tests whether ~P~ is monic. Equivalent to ~P.lead_coeff().is_one()~.

- P.make_monic() -> poly

  Forces the polynomial to be monic by multiplying by ~1/P.lead_coeff()~.

  *Finite characteristic only.*

- P.is_irreducible(method=0) -> bool

  Tests whether ~P~ is irreducible.

  The method argument is ignored for now.

  *Finite characteristic only.*

- P.factor(method='CanZass', verbose=False) -> [(poly, int)]

  Factors a polynomial into irreducible factors.

  Returns a list of tuple pairs giving the factor and its multiplicity.

  The ~method~ argument is ignored for now. The ~verbose~ flag is
  passed on to NTL.

  *Finite characteristic only.*
  
** Vectors
[todo]
** Matrices
[todo]

